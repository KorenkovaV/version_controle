# Инструкция по работе с git

## 1. Проверка наличия установленного git.

В терминале выполнить команду `git version`

Если git установлен, появится сообщение с информацией о версии программы. Иначе возникнет сообщение об ошибке.

## 2. Установка git
Если git не установлен, загружаем последнюю версию с сайта https://git-scm.com/downloads

Устанавливаем настройки по умолчанию.

## 3. Настройка git
При первом запуске git необходимо представиться. Для этого нужно ввести в терминал две команды:
```
git config --global user.name "Ваше имя"

git config --global user.email "email@example.com"
```

## 4. Инициализация репозитория
Получить репозиторий можно двумя способами.

1. В терминале перейти к папке, в которой хотим создать репозиторий. Выполняем команду `git init`. В исходной папке появится скрытая папка *.git*, содержащая все необходимые файлы репозитория - *структуру git репозитория*.
2. Или клонировать уже существующий репозиторий git из любого места с помощью команды `git clone`.

В обоих случаях вы получите готовый к работе Git репозиторий на вашем компьютере.

## 5. Запись изменений в репозиторий

Для работы с git необходимо знать несколько основополагающих комманд:

1. `git status` - показывает текущее состояние файлов в репозитории
2. `git add` - данная команда *подготавливает* внесенные изменения для дальнейшей их записи в репозиторий
3. `git commit -m` - записывает в репозиторий внесенные изменения, параметр -m обязателен: при каждом коммите необходимо указать сутевой комментарий, какие изменения были зафиксированны.
4. `git diff` - показывает разницу между последней закоммиченой версией и текущей, а именно какие изменения были внесены: добавлено/удалено. 

## 6. Просмотр истории коммитов

При работе с git необходимо уметь просматривать историю коммитов для помимания того, как создавался проект. Эту задачу выполняет комманда `git log`. Данная команда перечисляет все коммиты с хэш-кодами, именем и электронной почтной, датой создания и соответствующими коментариями в хронологическом порядке. По умолчанию последние коммиты находятся вверху.

Каждый коммит имеет свой индивидуальный идентификатор (хэш-код), который можно использовать для возвращения к определненному состоянию проекта. 

Для выхода из режима просмотра истории используется клавиша **"Q"**.

## 7. Перемещения между сохранениями

Для перемещения между сохранеными состояниями пректа можно использовать команду `git checkout <хеш код>` (в новых версиях git также подходит команда `git switch`). Также данные команды применяются для перехода между существующими ветками, только вместо хэш-кода указывается имя ветки в которую нужно переместиться.

Чтобы увидеть предыдущее сохранение, необходимо вызвать одну из команд с хэш-кодом соответствующего сохранения, например:
```
git checkout 2da35ee
```
*Для возвращения к прошлой версии достаточно указать от 4-х начальных символов соответствующего идентификатора.*

Такой переход использоуется только для просмотра! Продолжить работу над файлом можно только после перехода на **главную** ветку с помощью команды `git checkout master`.

## 8. Игнорирование файлов

Если в репозитории лежат файлы, которые нет необходимости отслеживать, например, картинки, то их можно проигнорировать.

Для этого используется специальный файл, который называется **`.gitignore`**. **_Принципиально важно поставить в названии файла точку в начале!_**

В данном документе прописываются имена файлов, которые следует игнорировать и после того, как .gitignore закоммитить, git перестанет выводить при проверке статуса имена указанных неотслеживаемых файлов.

Неотслеживаемые файлы отображаются в гите серым текстом.

## 9. Добавление изображения
Синтаксис для вставки изображений простой: 
`![текст](имя_файла)`:

![Japan](Japan.jpg)

## 10. Ветки в git
Для безопасной работы с гитом принято использовать ветки. 

Команда `git branch` выводит список всех веток, которые есть в репозитории.
Звездочкой (*) помечается та ветка, в которой пользователь находится в данный момент, например:
```
$ git branch 
* branches
  master
```
Git показал, что пользователь находится на ветке `branches`.

Если над проектом работают несколько человек или нужно протестировать/попробовать что-то новое и т.п., то создаются новые ветки, где это все реализуется. 

Чтобы создать новую ветку необходимо отправить команду `git branch <branch_name>` и потом перейти в нее с помощью команд `git checkout <branch_name>` или `git switch <branch_name>`.

Или можно одной командой создать ветку и сразу в нее перейти: `git checkout -b <branch_name>` или `git switch -c <branch_name>`.

После можно работать с проектом и не бояться "испортить" основную версию.

Если вызвать команду `git log` в одной из веток, то будет отображена вся история в обратном направлении до первого коммита главной ветки. Однако если вызвать лог в основной ветке, то будет отображена история **только** основной ветки, а коммиты соседних веток будут вне зоны отображения.

Когда все проверки завершены, только тогда итоговый, "чистый" вариант "сливается (`git merge`) с основной веткой. Стоит обратить внимание, что команда `git merge` вызывается в той ветке, **куда вносятся данные соседней ветки**, например:
```
Вера@DESKTOP-94P14FC MINGW64 ~/Desktop/version_control (branches)
$ git merge hw3 
Updating cd3ec01..e1ce136
Fast-forward
 git_insruction.md | 27 +++++++++++++++++++++++++++
 1 file changed, 27 insertions(+)
```
Данный результат слияния показывает, что пользователь находился в ветке **branches**, куда и была влита ветка **hw3** вместе со всем её содержимым.

Данное слияние произошло без конфликтов, так как изменения в ветке **hw3** не затрагивали данные ветки **branches**.

В противном случае, когда при слиянии возникает конфликт, git предлагает выбрать один из четырех вариантов для разрешения ситуации:
* принять текущую версию (Accept Current Change)
* принять предлагаемое изменение (Accept Incoming Change)
* принять обе версии (Accept Both Changes)
* сравнить версии (Compare Changes)

После того, как конфликт был решен, нужно закоммитить изменения.

Слияние можно прервать, отменить попытку слияния с помощью команды `git merge --abort`. Эта команда попытаектся откатить состояние репозитория до того, которое было до запуска слияния. Однако данная команда может завершиться неудачно, если до слияния не были зафиксированы изменения в репозитории.

Если слитая ветка больше не нужна, то ее можно удалить с помощью команды `git branch -d <branch_name>`.

Однако если ветка, которую пользователь намерен удалить, еще не была слита ни с какой другой, тогда гит выдаст ошибку и остановит ее удаление во избежание потери важной информации.

Если все же решено, что ветка по какой-бибо причине не нужна ни при каких обстоятельствах, тогда вместо параметра **-d** импользуется параметр **-D**, который вызывает принудительное удаление ветки. Этот прием довольно опасен и обычно используется только в крайних случаях.

Чтобы визуализировать коммиты, можно использовать команду `git log --graph`, которая наглядно показывает дерево коммитов с ветками.

Если сильно напортачили со слиянием, да и вообще при других серьезных косяках, можно попробовать откатить репозиторий к одному из его прошлых состояний: `git reflog`.
>Команда git reflog показывает список всего, что вы сделали. Затем она позволяет воспользоваться инструментами Git для отката изменений, для возврата к одному из прошлых состояний репозитория.

## 11 Работа с удаленными репозиториями
Для комфортной работы в команде, чтобы каждый участник имел доступ к рабочему репозиторию, используют один из популярных сервисов `github.com` 

Github - это сервис, где хранятся тысячи репозиториев разработчиков со всего света.
Через поиск можно находить разных авторов, находить разные проекты и принимать в них участие. 

Одним из возможных методов копирования репозитория с гитхаб является его клонирование с помощью команды `git clone <https://github.com/...>`.

Гит скопирует тот репозиторий, который находится на сервисе гитхаб в наш локальный репозиторий, т.е. на компьютере появится его полная и точная копия со всеми файлами. В папке, где была вызвана команда, появится еще папка с репозиторием с сайта. 

```
Важно запомнить, что вложенные репозитории (репозиторий внутри репозитория) - это плохой тон. Папка, куда клонируется репозиторий, не должна сама быть репозиторием! Папка, в которой несколько репозитоиев - норма.
```
Если на данном этапе проверить статус, то гит выдаст ошибку, т.к. в текущей папке не настроен репозиторий.

Далее необходимо переместиться в скопированную папку, чтобы с ней можно было взаимодействовать. Для этого выполняется команда `cd <repo_name>`. cd - change directory. После чего при проверке статуса гит покажет, что существует репозиторий и никаких изменений не обнаружено.

Теперь можно работать с репозиторием, однако связи с версией на гитхабе этот репо уже не имеет.

Чтобы локальный репозиторий отправить на гитхаб, сначала необходимо там зарегистрироваться. (Скачать чужой репозиторий можно и без регистрации, однако, чтобы залить свой - регистрация обязательна).

Далее уже в аккаунте через добавление нового удаленного репозитория создаем публичный репозиторий, который можно связать с локальным репозиторием, либо работать непосредственно на гитхабе, либо импортировать код из другого репозитория.

Чтобы связать наш локальный репозиторий с удаленным, используется следующая связка команд:

`git remote add origin <https://github.com/адрес_удаленного_репозитория>` - даем понять гиту, что появляется удаленный репозиторий и даем на него ссылку (remote - удаленный). Происходит магия связывания локального и удаленного репозиториев. Origin - название удаленного репозитория по умолчанию (можно указать любое).

`git branch -M main` - далее указывается какая ветка будет являться основной.

`git push -u origin main` - направляем то, что уже есть на локальном репозитории в интернет. (Push - толкать/направлять)

При первом связывании гита, который находится локально, с сервисом гитхаб, необходимо будет "подружить" их с помощью авторизации, которую будет предложено пройти. Это своего рода процедура верификации и пресечение несанкционированных изменений чужих репозиториев :)

После успешной авторизации на гитхабе появится версия локального репозитория, которая была направлена в интернет.

Теперь можно поделиться репозиторием с другими людьми посредством ссылки на него на гитхабе.

Стоит отметить, что изменения не отправляются на гитхаб в режиме онлайн. Все изменени в локальном репозитории остаются локальными до тех пор, пока гиту не дадут команду `git push`. Только после этого на гитхабе появятся внесенные изменения.

Если на гитхабе версия файла новее, чем локальная, тогда чтобы ее актуализировать, используют команду `git pull` (pull - тянуть, вытягивать). 

Данная команда является составной, т.е. помимо того, что версия актуализируется, гит еще пытается автоматически слить локальную версию файла с удаленной. Push, кстати, тоже составная команда.

## 12. Работа с удаленными репозиториями (pull request)
Если, например, ведется работа над большим проектом и доступ к удаленному репозиторию есть только у нескольких "избранных", а поучаствовать ну очень хочется, в таком случае есть возможность предложить свои помощь/изменения/улучшения с помощью `pull request` - запрос на вливание изменений в чужой репозиторий.

Сразу запоминаем, чтобы иметь возможность сделать **pull request** необходимо для начала скопировать интересующий нас репозиторий к себе в аккаунт с помощью команды `fork` (вилка). После этого в нашем аккаунте появится точная копия того проекта (репозитория), в который мы хотели привнести свой вклад. В нашем аккаунте будет отмечено, что репозиторий `forked from <user_name>`.

Далее уже с нашего аккаунта можно клонировать репозиторий к себе на компьютер, как указано в разделе 11.

Общепринято в склонированном репозитории создать отдельную ветку, в которой и будут производиться доработки проекта и т.п.

После всех манипуляций, доработанный репозиторий пушится на наш аккаунт как обычно через `git push`. Если делать пуш из новой ветки, то гит услужливо предложит команду как правильно залить изменения на гитхаб: `git push --set-upstream otigin <new_branch_name>`/

Когда изменения удачно залиты на гитхаб, то в форкнутом репозитории на нашем аккаунте появится новая ветка, а также заветная кнопочка `compare & pull request`.

Далее гитхаб проанализирует предлагаемые изменения, сравнит их, если все хорошо, то напишет, что изменения `able to merge`. Также нужно написать краткое сообщение владельцу основного репозитория.

И остается только направить запрос на изменение `create pull request`.

Далее уже владелец основного репозитория решает, подходят ли ему предлагаемые изменения. И если да, то он может влить предложенную ветку в свой проект.

Именно так происходит работа над open source проектами (пректами с открытым исходным кодом)

Удачи!